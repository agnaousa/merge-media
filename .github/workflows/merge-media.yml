name: Merge Audio and Video

permissions:
  contents: write  # ✅ This line gives write access to the repository

on:
  workflow_dispatch:
    inputs:
      video_path:
        description: "Path to the video file or URL"
        required: true
        default: "input/video.mp4"
      audio_path:
        description: "Path to the audio file or URL (ignored if audio_base64 is provided)"
        required: false
        default: "input/audio.mp3"
      audio_base64:
        description: "Base64 encoded audio data (JSON format: {\"audio_base64\":\"...\",\"content_type\":\"audio/mpeg\"})"
        required: false
        default: ""
      output_path:
        description: "Path for the output merged file"
        required: true
        default: "output/merged.mp4"
      audio_handling:
        description: "How to handle existing video audio"
        required: false
        default: "replace"
        type: choice
        options:
          - "replace"
          - "mix"
          - "keep_video"
      webhook_url:
        description: "Optional webhook URL to notify when processing is complete"
        required: false
        default: ""
  repository_dispatch:
    types: [merge-media]
  push:
    paths:
      - 'webhook-trigger.json'

jobs:
  merge:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Parse input parameters
        id: params
        run: |
          # Install jq if needed for JSON parsing
          which jq || sudo apt-get update && sudo apt-get install -y jq
          
          # Determine the source of the trigger and extract parameters
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Triggered via workflow_dispatch"
            echo "video_path=${{ github.event.inputs.video_path }}" >> $GITHUB_OUTPUT
            echo "audio_path=${{ github.event.inputs.audio_path }}" >> $GITHUB_OUTPUT
            echo "audio_base64=${{ github.event.inputs.audio_base64 }}" >> $GITHUB_OUTPUT
            echo "output_path=${{ github.event.inputs.output_path }}" >> $GITHUB_OUTPUT
            echo "audio_handling=${{ github.event.inputs.audio_handling }}" >> $GITHUB_OUTPUT
            echo "webhook_url=${{ github.event.inputs.webhook_url }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "Triggered via repository_dispatch (webhook)"
            # Check if data is in client_payload (standard format) or direct fields (custom format)
            if [ -n "${{ github.event.client_payload.video_path || github.event.video_path || '' }}" ]; then
              echo "video_path=${{ github.event.client_payload.video_path || github.event.video_path || 'input/video.mp4' }}" >> $GITHUB_OUTPUT
              echo "audio_path=${{ github.event.client_payload.audio_path || github.event.audio_path || 'input/audio.mp3' }}" >> $GITHUB_OUTPUT
              echo "audio_base64=${{ github.event.client_payload.audio_base64 || github.event.audio_base64 || '' }}" >> $GITHUB_OUTPUT
              echo "output_path=${{ github.event.client_payload.output_path || github.event.output_path || 'output/merged.mp4' }}" >> $GITHUB_OUTPUT
              echo "audio_handling=${{ github.event.client_payload.audio_handling || github.event.audio_handling || 'replace' }}" >> $GITHUB_OUTPUT
              echo "webhook_url=${{ github.event.client_payload.webhook_url || github.event.webhook_url || '' }}" >> $GITHUB_OUTPUT
            else
              echo "Using default values for repository_dispatch"
              echo "video_path=input/video.mp4" >> $GITHUB_OUTPUT
              echo "audio_path=input/audio.mp3" >> $GITHUB_OUTPUT
              echo "audio_base64=" >> $GITHUB_OUTPUT
              echo "output_path=output/merged.mp4" >> $GITHUB_OUTPUT
              echo "audio_handling=replace" >> $GITHUB_OUTPUT
              echo "webhook_url=" >> $GITHUB_OUTPUT
            fi
          elif [ "${{ github.event_name }}" = "push" ]; then
            echo "Triggered via push to webhook-trigger.json"
            # Read parameters from the webhook-trigger.json file
            if [ -f "webhook-trigger.json" ]; then
              VIDEO_PATH=$(jq -r '.video_path // "input/video.mp4"' webhook-trigger.json)
              AUDIO_PATH=$(jq -r '.audio_path // "input/audio.mp3"' webhook-trigger.json)
              AUDIO_BASE64=$(jq -r '.audio_base64 // ""' webhook-trigger.json)
              OUTPUT_PATH=$(jq -r '.output_path // "output/merged.mp4"' webhook-trigger.json)
              AUDIO_HANDLING=$(jq -r '.audio_handling // "replace"' webhook-trigger.json)
              WEBHOOK_URL=$(jq -r '.webhook_url // ""' webhook-trigger.json)
              echo "video_path=${VIDEO_PATH}" >> $GITHUB_OUTPUT
              echo "audio_path=${AUDIO_PATH}" >> $GITHUB_OUTPUT
              echo "audio_base64=${AUDIO_BASE64}" >> $GITHUB_OUTPUT
              echo "output_path=${OUTPUT_PATH}" >> $GITHUB_OUTPUT
              echo "audio_handling=${AUDIO_HANDLING}" >> $GITHUB_OUTPUT
              echo "webhook_url=${WEBHOOK_URL}" >> $GITHUB_OUTPUT
            else
              echo "webhook-trigger.json not found, using defaults"
              echo "video_path=input/video.mp4" >> $GITHUB_OUTPUT
              echo "audio_path=input/audio.mp3" >> $GITHUB_OUTPUT
              echo "audio_base64=" >> $GITHUB_OUTPUT
              echo "output_path=output/merged.mp4" >> $GITHUB_OUTPUT
              echo "audio_handling=replace" >> $GITHUB_OUTPUT
              echo "webhook_url=" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Set up FFmpeg
        run: sudo apt-get update && sudo apt-get install -y ffmpeg

      - name: Download media files if URLs provided
        id: download
        run: |
          VIDEO_PATH="${{ steps.params.outputs.video_path }}"
          AUDIO_PATH="${{ steps.params.outputs.audio_path }}"
          AUDIO_BASE64="${{ steps.params.outputs.audio_base64 }}"
          
          # Function to check if a string is a URL
          is_url() {
            echo "$1" | grep -E "^https?://" > /dev/null
          }
          
          # Handle video input
          if is_url "$VIDEO_PATH"; then
            echo "Video input is a URL: $VIDEO_PATH"
            echo "Downloading video file..."
            mkdir -p temp
            VIDEO_EXT=$(echo "$VIDEO_PATH" | grep -oE '\.(mp4|avi|mov|mkv|webm|flv)(\?.*)?$' | sed 's/\?.*//' || echo ".mp4")
            LOCAL_VIDEO_PATH="temp/downloaded_video${VIDEO_EXT}"
            
            if curl -L -o "$LOCAL_VIDEO_PATH" "$VIDEO_PATH"; then
              echo "Video downloaded successfully"
              echo "local_video_path=$LOCAL_VIDEO_PATH" >> $GITHUB_OUTPUT
            else
              echo "Failed to download video from URL"
              exit 1
            fi
          else
            echo "Video input is a local path: $VIDEO_PATH"
            echo "local_video_path=$VIDEO_PATH" >> $GITHUB_OUTPUT
          fi
          
          # Handle audio input - check for base64 data in either audio_base64 or audio_path fields
          AUDIO_JSON=""
          BASE64_DATA=""
          CONTENT_TYPE="audio/mpeg"
          
          # First check if audio_base64 field has data
          if [ -n "$AUDIO_BASE64" ] && [ "$AUDIO_BASE64" != "" ]; then
            AUDIO_JSON="$AUDIO_BASE64"
            echo "Processing base64 encoded audio data from audio_base64 field..."
          # Then check if audio_path contains JSON with base64 data
          elif echo "$AUDIO_PATH" | jq -e '.audio_base64' >/dev/null 2>&1; then
            AUDIO_JSON="$AUDIO_PATH"
            echo "Processing base64 encoded audio data from audio_path field (JSON format)..."
          fi
          
          # If we found JSON data with base64, process it
          if [ -n "$AUDIO_JSON" ]; then
            mkdir -p temp
            
            # Parse the JSON input to extract base64 data and content type
            if echo "$AUDIO_JSON" | jq -e . >/dev/null 2>&1; then
              # Valid JSON format
              BASE64_DATA=$(echo "$AUDIO_JSON" | jq -r '.audio_base64 // empty')
              CONTENT_TYPE=$(echo "$AUDIO_JSON" | jq -r '.content_type // "audio/mpeg"')
            else
              # Assume it's just the base64 string
              BASE64_DATA="$AUDIO_JSON"
              CONTENT_TYPE="audio/mpeg"
            fi
            
            if [ -z "$BASE64_DATA" ]; then
              echo "Error: No base64 audio data found in input"
              exit 1
            fi
            
            # Determine file extension from content type
            case "$CONTENT_TYPE" in
              "audio/mpeg"|"audio/mp3")
                AUDIO_EXT=".mp3"
                ;;
              "audio/wav"|"audio/wave")
                AUDIO_EXT=".wav"
                ;;
              "audio/aac")
                AUDIO_EXT=".aac"
                ;;
              "audio/ogg")
                AUDIO_EXT=".ogg"
                ;;
              "audio/m4a")
                AUDIO_EXT=".m4a"
                ;;
              "audio/flac")
                AUDIO_EXT=".flac"
                ;;
              *)
                echo "Warning: Unknown content type '$CONTENT_TYPE', defaulting to .mp3"
                AUDIO_EXT=".mp3"
                ;;
            esac
            
            LOCAL_AUDIO_PATH="temp/decoded_audio${AUDIO_EXT}"
            
            # Decode base64 data to file
            if echo "$BASE64_DATA" | base64 -d > "$LOCAL_AUDIO_PATH"; then
              # Verify the file was created and has content
              if [ -s "$LOCAL_AUDIO_PATH" ]; then
                echo "Base64 audio decoded successfully"
                echo "Content type: $CONTENT_TYPE"
                echo "File size: $(du -h "$LOCAL_AUDIO_PATH" | cut -f1)"
                echo "local_audio_path=$LOCAL_AUDIO_PATH" >> $GITHUB_OUTPUT
              else
                echo "Error: Decoded audio file is empty"
                exit 1
              fi
            else
              echo "Error: Failed to decode base64 audio data"
              exit 1
            fi
          elif is_url "$AUDIO_PATH"; then
            echo "Audio input is a URL: $AUDIO_PATH"
            echo "Downloading audio file..."
            mkdir -p temp
            AUDIO_EXT=$(echo "$AUDIO_PATH" | grep -oE '\.(mp3|wav|aac|ogg|m4a|flac)(\?.*)?$' | sed 's/\?.*//' || echo ".mp3")
            LOCAL_AUDIO_PATH="temp/downloaded_audio${AUDIO_EXT}"
            
            if curl -L -o "$LOCAL_AUDIO_PATH" "$AUDIO_PATH"; then
              echo "Audio downloaded successfully"
              echo "local_audio_path=$LOCAL_AUDIO_PATH" >> $GITHUB_OUTPUT
            else
              echo "Failed to download audio from URL"
              exit 1
            fi
          else
            echo "Audio input is a local path: $AUDIO_PATH"
            echo "local_audio_path=$AUDIO_PATH" >> $GITHUB_OUTPUT
          fi

      - name: Generate unique output filename
        id: output
        run: |
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          RUN_ID=${{ github.run_id }}
          BASENAME=$(basename "${{ steps.params.outputs.output_path }}" .mp4)
          DIRNAME=$(dirname "${{ steps.params.outputs.output_path }}")
          UNIQUE_OUTPUT="${DIRNAME}/${BASENAME}_${TIMESTAMP}_${RUN_ID}.mp4"
          echo "unique_output=${UNIQUE_OUTPUT}" >> $GITHUB_OUTPUT
          echo "Generated unique output path: ${UNIQUE_OUTPUT}"

      - name: Validate input files
        run: |
          if [ ! -f "${{ steps.download.outputs.local_video_path }}" ]; then
            echo "Error: Video file not found at ${{ steps.download.outputs.local_video_path }}"
            exit 1
          fi
          if [ ! -f "${{ steps.download.outputs.local_audio_path }}" ]; then
            echo "Error: Audio file not found at ${{ steps.download.outputs.local_audio_path }}"
            exit 1
          fi
          echo "Input files validated successfully"

      - name: Create output directory
        run: |
          mkdir -p "$(dirname "${{ steps.output.outputs.unique_output }}")"
          echo "Output directory created: $(dirname "${{ steps.output.outputs.unique_output }}")"

      - name: Merge audio with video
        run: |
          echo "Starting merge process..."
          echo "Video: ${{ steps.params.outputs.video_path }}"
          echo "Audio: ${{ steps.params.outputs.audio_path }}"
          echo "Local Video: ${{ steps.download.outputs.local_video_path }}"
          echo "Local Audio: ${{ steps.download.outputs.local_audio_path }}"
          echo "Output: ${{ steps.output.outputs.unique_output }}"
          echo "Audio handling: ${{ steps.params.outputs.audio_handling }}"
          
          case "${{ steps.params.outputs.audio_handling }}" in
            "replace")
              echo "Replacing video audio with new audio..."
              AUDIO_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "${{ steps.download.outputs.local_audio_path }}")
              ffmpeg -y \
                     -i "${{ steps.download.outputs.local_video_path }}" \
                     -i "${{ steps.download.outputs.local_audio_path }}" \
                     -filter_complex "[0:v]loop=loop=-1:size=32767:start=0[looped_video]; [looped_video]setpts=PTS-STARTPTS[v]" \
                     -map "[v]" \
                     -map 1:a \
                     -c:v libx264 \
                     -c:a aac \
                     -t ${AUDIO_DURATION} \
                     "${{ steps.output.outputs.unique_output }}"
              ;;
            "mix")
              echo "Mixing video audio with new audio..."
              AUDIO_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "${{ steps.download.outputs.local_audio_path }}")
              ffmpeg -y \
                     -i "${{ steps.download.outputs.local_video_path }}" \
                     -i "${{ steps.download.outputs.local_audio_path }}" \
                     -filter_complex "[0:v]loop=loop=-1:size=32767:start=0[looped_video]; [looped_video]setpts=PTS-STARTPTS[v]; [0:a][1:a]amix=inputs=2:duration=longest[a]" \
                     -map "[v]" \
                     -map "[a]" \
                     -c:v libx264 \
                     -c:a aac \
                     -t ${AUDIO_DURATION} \
                     "${{ steps.output.outputs.unique_output }}"
              ;;
            "keep_video")
              echo "Keeping original video audio, ignoring new audio..."
              ffmpeg -y \
                     -i "${{ steps.download.outputs.local_video_path }}" \
                     -c:v copy \
                     -c:a aac \
                     "${{ steps.output.outputs.unique_output }}"
              ;;
            *)
              echo "Unknown audio handling option: ${{ steps.params.outputs.audio_handling }}"
              echo "Defaulting to replace mode..."
              AUDIO_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "${{ steps.download.outputs.local_audio_path }}")
              ffmpeg -y \
                     -i "${{ steps.download.outputs.local_video_path }}" \
                     -i "${{ steps.download.outputs.local_audio_path }}" \
                     -filter_complex "[0:v]loop=loop=-1:size=32767:start=0[looped_video]; [looped_video]setpts=PTS-STARTPTS[v]" \
                     -map "[v]" \
                     -map 1:a \
                     -c:v libx264 \
                     -c:a aac \
                     -t ${AUDIO_DURATION} \
                     "${{ steps.output.outputs.unique_output }}"
              ;;
          esac
          
          echo "Merge completed successfully!"
          echo "Output file size: $(du -h "${{ steps.output.outputs.unique_output }}" | cut -f1)"

      - name: Upload merged file as artifact
        uses: actions/upload-artifact@v4
        with:
          name: merged-video
          path: ${{ steps.output.outputs.unique_output }}

      - name: Commit merged file
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          
          # Add the generated file to git
          git add "${{ steps.output.outputs.unique_output }}"
          
          # Check if there are any staged changes
          if git diff --staged --quiet; then
            echo "No changes staged for commit (file may already exist or wasn't created)"
          else
            git commit -m "Add merged video: ${{ steps.output.outputs.unique_output }}"
            git push
            echo "Changes committed and pushed successfully"
          fi

      - name: Generate output URL
        id: url
        run: |
          # Generate the URL to access the output file
          OUTPUT_FILE="${{ steps.output.outputs.unique_output }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          BRANCH="${{ github.ref_name }}"
          FILE_URL="${REPO_URL}/blob/${BRANCH}/${OUTPUT_FILE}"
          RAW_URL="https://raw.githubusercontent.com/${{ github.repository }}/${BRANCH}/${OUTPUT_FILE}"
          
          echo "file_url=${FILE_URL}" >> $GITHUB_OUTPUT
          echo "raw_url=${RAW_URL}" >> $GITHUB_OUTPUT
          echo "filename=$(basename "${OUTPUT_FILE}")" >> $GITHUB_OUTPUT
          
          echo "Generated URLs:"
          echo "File URL: ${FILE_URL}"
          echo "Raw URL: ${RAW_URL}"

      - name: Send completion webhook
        if: steps.params.outputs.webhook_url != ''
        run: |
          WEBHOOK_URL="${{ steps.params.outputs.webhook_url }}"
          
          if [ -n "$WEBHOOK_URL" ]; then
            echo "Sending completion notification to webhook: $WEBHOOK_URL"
            
            # Check if output file exists and get its size
            OUTPUT_FILE="${{ steps.output.outputs.unique_output }}"
            if [ -f "$OUTPUT_FILE" ]; then
              FILE_SIZE=$(stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo "unknown")
              STATUS="completed"
              ERROR_MESSAGE=""
            else
              FILE_SIZE="0"
              STATUS="failed"
              ERROR_MESSAGE="Output file was not created"
            fi
            
            PAYLOAD=$(cat <<EOF
          {
            "status": "$STATUS",
            "workflow_run_id": "${{ github.run_id }}",
            "repository": "${{ github.repository }}",
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "input": {
              "video_path": "${{ steps.params.outputs.video_path }}",
              "audio_path": "${{ steps.params.outputs.audio_path }}",
              "audio_base64_provided": "${{ steps.params.outputs.audio_base64 != '' && 'true' || 'false' }}",
              "output_path": "${{ steps.params.outputs.output_path }}",
              "audio_handling": "${{ steps.params.outputs.audio_handling }}"
            },
            "output": {
              "file_path": "${{ steps.output.outputs.unique_output }}",
              "file_url": "${{ steps.url.outputs.file_url }}",
              "raw_url": "${{ steps.url.outputs.raw_url }}",
              "filename": "${{ steps.url.outputs.filename }}",
              "file_size": "$FILE_SIZE"
            },
            "artifacts": {
              "artifact_name": "merged-video",
              "download_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            },
            "error_message": "$ERROR_MESSAGE"
          }
          EOF
            )
            
            # Send the webhook with retry logic
            RETRY_COUNT=0
            MAX_RETRIES=3
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              HTTP_CODE=$(curl -w "%{http_code}" -o /tmp/webhook_response.txt \
                               -X POST \
                               -H "Content-Type: application/json" \
                               -H "User-Agent: GitHub-Actions-Merge-Media/1.0" \
                               -d "$PAYLOAD" \
                               --max-time 30 \
                               --retry 2 \
                               --silent \
                               "$WEBHOOK_URL")
              
              if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
                echo "Webhook sent successfully! HTTP $HTTP_CODE"
                echo "Response: $(cat /tmp/webhook_response.txt)"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                echo "Webhook failed with HTTP $HTTP_CODE (attempt $RETRY_COUNT/$MAX_RETRIES)"
                echo "Response: $(cat /tmp/webhook_response.txt)"
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Retrying in 10 seconds..."
                  sleep 10
                fi
              fi
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "❌ Failed to send webhook after $MAX_RETRIES attempts"
              echo "Final HTTP Code: $HTTP_CODE"
              echo "Payload that failed to send:"
              echo "$PAYLOAD"
              # Don't fail the workflow, just log the error
              exit 0
            fi
          else
            echo "No webhook URL provided, skipping notification"
          fi

      - name: Send error webhook on failure
        if: failure() && steps.params.outputs.webhook_url != ''
        run: |
          WEBHOOK_URL="${{ steps.params.outputs.webhook_url }}"
          
          if [ -n "$WEBHOOK_URL" ]; then
            echo "Sending error notification to webhook: $WEBHOOK_URL"
            
            ERROR_PAYLOAD=$(cat <<EOF
          {
            "status": "failed",
            "workflow_run_id": "${{ github.run_id }}",
            "repository": "${{ github.repository }}",
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "input": {
              "video_path": "${{ steps.params.outputs.video_path || 'unknown' }}",
              "audio_path": "${{ steps.params.outputs.audio_path || 'unknown' }}",
              "audio_base64_provided": "${{ steps.params.outputs.audio_base64 != '' && 'true' || 'false' }}",
              "output_path": "${{ steps.params.outputs.output_path || 'unknown' }}",
              "audio_handling": "${{ steps.params.outputs.audio_handling || 'unknown' }}"
            },
            "error_message": "Workflow failed during processing. Check the GitHub Actions logs for details.",
            "logs_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF
            )
            
            curl -X POST \
                 -H "Content-Type: application/json" \
                 -H "User-Agent: GitHub-Actions-Merge-Media/1.0" \
                 -d "$ERROR_PAYLOAD" \
                 --max-time 30 \
                 "$WEBHOOK_URL" || echo "Failed to send error webhook"
          fi
